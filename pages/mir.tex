\subsection{Међурепрезентација средњег нивоа (МСН) - Mid-Level Intermediate Representation (MIR)}

Концепт међурепрезентације средњег нивоа није постојао од самог настанка компајлера. Првобитно је користио апстрактно синтаксно стабло 
из иницијалног парсирања све до финалне генерације биткода. Овај метод је доводио до бројних проблема. Апстрактно синтаксно стабло и репрезентација 
високог нивоа су изгледом веома слични изворном коду. Превођење синтактичког шећера на основни конструкт није имало предодређено место за чување. 
Стога свака фаза која је морала да расуђује нешто на основу кода (нпр. провера типова, генерисање кода) је морала да симулира превођење од почетка.
Са обзиром да би свака фаза морала бити упозната са сваким специјалним случајем превођења, крајњи резултат упрошћавања шећера би чинило компајлер 
комплекснијим, а не једноставнијим. Расуђивање контроле тока преко апстрактног синтаксног стабла је веома комплексно. Граф контроле тока се креирао
изнад АСС-а, користо се за анализу али не и током превођења, чиме се анализиран граф контроле тока није морао подударати са графом контроле тока генерисаног кода. 
Постојала су бројна места на којима би било ефикасно употребити \verb|Rust| специфично знање за извршавање оптимизација где би постојање средњег слоја значајно помогло.
Мигрирање од \verb|LLVM|-а је било практично немогуће јер је семантика \verb|Rust| језика спојена са кораком превођења у \verb|LLVM| међурепрезентацију.
Формални докази су један од начина на који би \verb|Rust| волео да гарантује безбедност, и самим тиме претходно наведена, увек променљива 
основа није подобна за овај посао.

Наиме, увођење још једне међурепрезентације не долази без мана. Конвертовање из АСС-а у МСН уводи додатно време приликом компајлирања. Више труда је потребно 
да би се креирале квалитетне поруке о проблемима унутар кода јер је МСН значајно другачије структуре од онога што је корисник унео.

\subsubsection{Граф контроле тока}

Данас, средњу међурепрезентацију чини скуп фајлова (када се потражи од компајлера) где сваки описује извршавање једне функције и директно је везан за граф контроле тока. Граф контроле тока је 
структуиран као група основних блокова који су повезани гранама. Кључна идеја блока јесте да је то група наредби (исказа) 
која се извршава заједно. Сваки пут када се граном дође до новог блока, све наредбе тог блока морају да се изврше, па тек онда постоји могућност 
да се грана даље. Последња нареба унутар блока се назива терминатор. Бројни изрази \ref{lst:block_code} који се користе у \verb|Rust| језику се компајлирају на 
више основних блокова \ref{lst:block_block}.

\begin{listing}[H]
\begin{minted}{rust}
a = 1;
if some_variable {
    b = 1;
} else {
    c = 1;
}
d = 1;
\end{minted}
\caption{Исечак кода који се преводи у више основних блокова}
\label{lst:block_code}
\end{listing}


\begin{listing}[H]
\begin{minted}{text}
BB0: {
    a = 1;
    if some_variable {
        goto BB1;
    } else {
        goto BB2;
    }
}
BB1: {
    b = 1;
    goto BB3;
}
BB2: {
    c = 1;
    goto BB3;
}
BB3: {
    d = 1;
    ...
}
\end{minted}
\caption{Исечак кода у форми основних блокова}
\label{lst:block_block}
\end{listing}

Стек (\verb|Stack|) је ЛИФО (\verb|Last in First Out|) структура података коју компајлер користи да складишти аргументе функција,
локалне променљиве и привремене променљиве. У МСН репрезентацији меморијске локације на стеку су идентификоване помоћу индекса. 
Индекс се означава целобројном вредношћу коју претходи доња црта (нпр. \verb|_1|, \verb|_2|). Индекс \verb|_0| је специјалан, у њему
се складишти повратна вредност. Места су изрази који идентификују локацију у меморији. Место може бити сам индекс (\verb|_1|) или може бити
пројекција (\verb|_1.polje|). Пројекције су поља или друге конструкције које произилазе из места. Приступ пољу је пројекција, за \verb|_1.polje|, \verb|_1| је место док је \verb|polje| пројекциони елемент.
Дереференцирање је такође пројекција, за \verb|*_1|, \verb|_1| је место док је \verb|*| пројекциони елемент. 
Десне вредности (\verb|RValues|) су изрази који генеришу вредност. Зову се десне вредности зато што 
стоје са десне стране оператора доделе (\verb|=|). Операнди су аргументи десне вредности. Аргумент може бити константа или место (као што је \verb|_1|).

Структуру средње међурепрезентације је најлакше разумети превођењем једноставних програма попут \ref{lst:snippet-before-mir}. У додатку \ref{lst:unoptimized-mir} се налази неоптимизована његова средња међурепрезентација. Главна разлика између оптимизоване и неоптимизовање средње међурепрезентације јесте то што неоптимизована међурепрезентација садржи експлицитне исказе \verb|StorageLive| и \verb|StorageDead| унутар основних блокова. Исказ \verb|StorageLive| пружа информацију да је променљива наведена у исказу жива тј.
да ју је могуће користити у даљем извршавању. Исказ \verb|StorageDead| пружа информацију да је променљива наведена у исказу мртва
тј. није је више могуће користити. Самим тиме ово се показује као право место да се спроводи деалокација меморије.
Једина информација коју средња репрезентација не зна експлицитно јесте да ли се догодио пренос власништва. Ову информацију добија на основу типа променљиве.

\begin{listing}[H]
\begin{minted}{text}
fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);
}
\end{minted}
\caption{Исечак кода који се преводи у МСН}
\label{lst:snippet-before-mir}
\end{listing}

\subsubsection{Оптимизација кода у МСН-у}

Репрезентација средњег нивоа у \verb|Rust| компајлеру игра кључну улогу у оптимизацији кода пре његове предаје \verb|LLVM| бекенду. 
Генерише се из ТМВН-а и фокусира се искључиво на извршни код. Једна од главних предности МСН-а је омогућавање оптимизација специфичних за \verb|Rust| које би било тешко 
спровести директно на нивоу \verb|LLVM| ИР-а. МСН пружа основу за анализу безбедне примене оптимизација, 
јасно раздвајајући семантику језика од \verb|LLVM| бекенда. МСН тежи да поједностави репрезентацију кода, потенцијално олакшавајући формалне доказе у будућности.

Процес генерисања МСН-а рекурзивно обрађује изразе из ТМВН-а. Одличан пример оптимизације и поједностављења које МСН омогућава је 
трансформација петљи. На пример, \verb|for| петља, која се у ранијој фази МВН-а може своди на \verb|while let| конструкцију,
у МСН-у иницијално бива трансформисана у еквивалентну \verb|loop| петљу са \verb|match| изразом унутар ње:

\begin{listing}[H]
\begin{minted}{rust}
let mut iterator = IntoIterator::into_iter(vec);
loop {
    match Iterator::next(&mut iterator){
        Some(elem) => process(elem),
        None => break,
    }
}
\end{minted}
\caption{Оптимизација превођењем for петље у loop и match наредбе}
\label{lst:optimization-0}
\end{listing}

Ова структура пресликава семантику \verb|while let|, али МСН иде корак даље у поједностављењу контроле тока. Уводе се експлицитне \verb|goto| 
наредбе и лабеле. Иако је \verb|goto| кључна реч која није дозвољена у изворном \verb|Rust| коду због потенцијалног нарушавања читљивости и 
отежаног праћења тока извршавања у комплексним програмима, у интерној репрезентацији попут МСН-а он своди петље и гранања на најосновније 
операције скока. Ово чини граф контроле тока експлицитним и лакшим за анализу и даљу трансформацију од стране компајлера. 
Петља из претходног примера сада изгледа овако:

\begin{listing}[H]
\begin{minted}{rust}
let mut iterator = IntoIterator::into_iter(vec);

loop: 
    match Iterator::next(&mut iterator) {
        Some(elem) => { process(elem); goto loop; } 
        None => { goto break; } 
    }

break: 
\end{minted}
\caption{Оптимизација увођењем кључне речи goto}
\label{lst:optimization-1}
\end{listing}

Последњи корак у овом примеру је поједностављење \verb|match| израза, који је и даље релативно комплексна синтактичка целина. 
Док \verb|match| у изворном коду групише проверу обрасца и приступ подацима унутар њега, 
МСН га раздваја ради веће грануларности и једноставности основних операција. 
Уводи се примитивна \verb|switch| наредба (која није доступна у изворном \verb|Rust|-у) која се бави искључиво провером дискриминанте 
(да ли је резултат \verb|Some| или \verb|None|). Приступ подацима унутар варијанте 
(издвајање вредности \verb|elem| из \verb|Some|) обавља се као засебна операција унутар одговарајуће гране контроле тока:

\begin{listing}[H]
\begin{minted}{rust}
let mut iterator = IntoIterator::into_iter(vec);

loop:
    let tmp = Iterator::next(&mut iterator); 
    
    switch tmp { 
        Some => { 
            let elem = (tmp as Some).0; 
            process(elem); 
            goto loop; 
        }
        None => { 
            goto break; 
        }
    }
    
break:
\end{minted}
\caption{Оптимизација увођењем Switch наредбе}
\label{lst:optimization-2}
\end{listing}


Веома је често да приликом \verb|debug|-овања средње репрезентације потребан приказ само једне функције
уместо целокупног превода. За приказ целокупног излаза користи се \verb|all| филтер, док ако је нека појединачна функција од интересовања
њено име.

\begin{listing}[H]
\begin{minted}{bash}
cargo rustc -- -Z dump-mir=[filter] -Z dump-mir-graphviz
\end{minted}
\caption{Испис и приказ МСН-а}
\label{lst:mir_print}
\end{listing}

\subsubsection{Нелексички животни векови}

Позајмљивач (\verb|borrow-checker|) налаже да се позајмљена вредност не може мутирати нити јој се може променити власништво. Сваки пут када се вредност позајми креира се животни век њене референце. 
Животни век референце се односи на место кода где би се референца могла користити. Компајлер ће се потрудити да евалуира најмањи опсег који покрива свако потенцијално коришћење референце.
Животни век може да се односи и на вредност и на референцу. Да би било јасно о чему се говори, животни век ће се односити на животни век референце, док ће се опсег односити на животни век вредности \ref{lst:scope-lifetime}.

\begin{listing}[H]
\begin{minted}{rust}
fn foo() {
    let mut data = vec!['a', 'b', 'c'];    // --+ 'opseg
    capitalize(&mut data[..]);             //   |
//  ^~~~~~~~~~~~~~~~~~~~~~~~~ 'životni vek //   |
    data.push('d');                        //   |
    data.push('e');                        //   |
    data.push('f');                        //   |
} // <------------------------------------------+
\end{minted}
\caption{Опсег и животни век}
\label{lst:scope-lifetime}
\end{listing}

Лексички (статички) животни век се одређује на основу структуре програма. У примеру \ref{lst:lexical-lifetime} дефинише се мутабилна референца над вектором \verb|data|.
Референцу је могуће користити у целокупном опсегу функције, стога опсег функције чини њен животни век. То значи да су позиви \verb|push| грешка јер се дешавају током животног века
референце.

\begin{listing}[H]
\begin{minted}{rust}
fn bar() {
    let mut data = vec!['a', 'b', 'c'];
    let slice = &mut data[..]; // <-+ 'životni vek
    capitalize(slice);         //   |
    data.push('d'); // GREŠKA!  //   |
    data.push('e'); // GREŠKA!  //   |
    data.push('f'); // GREŠKA!  //   |
} // <------------------------------+
\end{minted}
\caption{Проблем код лексичког животног века}
\label{lst:lexical-lifetime}
\end{listing}

Овакви проблеми су се могли заобићи енкапсулирањем референце у блок \ref{lst:lexical-lifetime-ok}. Овај заобилазни пут је можда логичан али изгледа вештачки и отежава коришћење језика. 

\begin{listing}[H]
\begin{minted}{rust}
fn bar() {
    let mut data = vec!['a', 'b', 'c'];
    {
        let slice = &mut data[..]; // <-+ 'životni vek
        capitalize(slice);         //   |
    } // <------------------------------+
    data.push('d'); // OK
    data.push('e'); // OK
    data.push('f'); // OK
}
\end{minted}
\caption{Опсег и животни век}
\label{lst:lexical-lifetime-ok}
\end{listing}

Претходни пример је један од најједноставнијих проблема лексичког животног века, напреднији проблеми постају тежи за уочавање и још тежи за разумевање.
Увођењем МСН-а добијен је ефикасан начин евалуације животног века на основу контроле тока графа где се грануларно одређује животни век референце \ref{lst:dynamic-lifetime} (овако \verb|Rust| ради данас).

\begin{listing}[H]
\begin{minted}{rust}
fn bar() {
    let mut data = vec!['a', 'b', 'c'];
    let slice = &mut data[..];   // <-+ 'životni vek
    capitalize(slice);           //   |
    // <------------------------------+
    data.push('d'); // OK
    data.push('e'); // OK
    data.push('f'); // OK
} 
\end{minted}
\caption{Динамички животни век}
\label{lst:dynamic-lifetime}
\end{listing}
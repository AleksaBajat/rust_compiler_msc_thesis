\section{Rust компајлер}

\verb|Rust| компајлер у сваком тренутку поседује три главне верзије скупа алата (\verb|toolchain|): стабилна, бета и ноћна (\verb|nightly|) верзија.
Стабилна верзија компајлера је безбедна и препоручена за продукциону употребу. Бета верзија садржи функционалности
које се усвајају у наредној стабилној верзији. Ноћна верзија је верзија компајлера која се 
производи сваку ноћ, са свим најновијим нетестираним променама. Капија функционалности је механизам безбедности
који онемогућава да експерименталне (нестабилне) функционалности случајно заврше у продукцији. 
Капија је дефи\hyp{}нисана на основу стања капије, назива функционалности, верзије, броја захтева за повлачењем
(\verb|pull| \verb|request|) и опционог коментара.
Стање капије функционалности може бити нестабилно, обрисано или прихваћено и некомплетирано. Некомплетирано 
стање унутар капије даје до знања кориснику ноћне верзије или другим сарадницима да је нестабилна функционалност 
у развоју.  Нестабилне капије онемогућавају да стабилна и бета верзија компајлера компајлирају 
дати сегмент кода (игнорише се).  Самим тиме развој је директно 
усмерен ка ноћној верзији која је под надзором целокупног \verb|Rust| тима. Обрисане капије се не бришу физички из кода,
већ се статус капије промени у обрисан уз коментар са разлогом. На овај начин се чува историја покушаних 
функционалности са разлозима који су узроковали брисање. У случају да се сличан захтев поново јави, ретроспектива
служи као моћан алат који ће идеално упозорити сараднике и преусмеравати их на бољи правац.

\begin{listing}[H]
\begin{minted}{rust}
    (incomplete, pub_restricted, "CURRENT_RUSTC_VERSION", Some(32409)),
    (unstable, pub_restricted, "CURRENT_RUSTC_VERSION", Some(32409))
    (accepted, pub_restricted, "CURRENT_RUSTC_VERSION", Some(32409)),
    (removed, pub_restricted, "CURRENT_RUSTC_VERSION", 
    Some(32409), Some("Removed because.."))
\end{minted}
\caption{Капија функционалности}
\label{lst:rustup_set}
\end{listing}

Свака функционалност пролази кроз дугачак процес провера пре него 
што се усвоји. Уколико функционалност захтева промене које нису реорганизација, рефакторисање, документовање
и слично, креира се захтев за коментаре (\verb|RFC|) који детаљно објашњава важност функционалности и 
преглед имплементационих детаља са висине. У супротном овај сегмент се прескаче. Стејкхолдери као што је \verb|Rust| компајлер тим, али и сама \verb|Rust| заједница 
има право да вага о потенцијалним импликацијама које функционалност доноси. Одобравање захтева значи почетак 
развоја али не гарантује усвајање. Уколико је функционалност развијена, покривена тестовима, 
без значајних примедби, било који сарадник може покренути захтев за стабилизацију. Захтев је конституиран из 
четири дела: документационог \verb|pull| \verb|request|-а, стабилизационог извештаја, 
периода финалног коментара и стабилизационог \verb|pull| \verb|request|-а.

Документација функционалности која се стабилизује се брише из нестабилне књиге \cite{unstable} и ажу\hyp{}рира се 
документација намењена корисницима језика. Корисници повлаче информације из ра\hyp{}зличитих делова документације,
наиме најбитније је детљно ажурирати књигу референци \cite{rust-reference} која описује сваку стабилну 
карактеристику језика. Нестаблина књига води релативно ажурну евиденцију о нестабилним функционалностима.
Свака нестабилна функционалност припада само једној од три поткатегорије: заставица компајлера, функционалност језика или
функционалност стандардне библиотеке. Стабилизациони извештај садржи примере који приказују нову каракте\hyp{}ристику 
у реалном сценарију, линкове ка документацији, као и објашњење подржано тестовима који описују понашање функционалности у 
граничним случајевима. Сарадник који прати ток развоја функционалности, уколико се слаже са процесом 
стабилизације, започиње период фи\hyp{}налног коментара. Остатак тима прегледа предлог и уколико је концензус
позитиван финални захтев за повлачењем се креира. Циљ је да се промени статус заставице у прихваћено
стање као и брисање макроа \verb|gate_feature_post!| који покреће грешку уколико се функционалност користи ван ноћне верзије компајлера.
Уколико је све задовољено, функционалност постаје ближа кра\hyp{}јњим корисницима за тестирање у бета верзији, док
неминовно не пређе у стабилну верзију у наредној стабилној дистрибуцији. 

Оригинална идеја иза нестабилних функционалности компајлера, поред очигледних безбе\hyp{}дносних погодности, 
јесте да се пружи приступ најновијим карактеристикама зарад тестирања и евалуације корисности.
Упркос томе 2023. године 12\%  пакета у \verb|Rust| екосистему се директно ослањало на нестабилне функционалности, а 
44\% пакета је индиректно зависило од нестабилних функционалности да би се компајлирало \cite{unstable-flags}. Иако 
статуси капија семантички омогућавају брисање капије без грубог брисања, компајлер константно мења архитектуру, чиме уједно 
решава проблеме због којих је постојање нестабилних функционалности било по\hyp{}требно. Наиме брисање капије 
у било ком облику означава да у следећој ноћној верзији, програм или библиотека зависна од нестабилне функционалности
неће моћи да се компајлира. То такође не гарантује да се нестабилна функционалности неће вратити већ у следећој
верзији и обрнуто. Иако се од стране заједнице пружа труд да се нестабилне функционалности прате, овакав вид 
развоја би се показао неефикасан јер сваки будући развој потенцијално захтева обазривост на нестабилне 
библиотеке што није циљ компајлера. Процентуална зависност према нестабилним функционалностима је висока али 
анализа није спроведена да се израчуна проценат масовно коришћених пакета са директним или транзитивним
зависностима, као и проценат нестабилних функционалности на којима се овакви пакети заснивају.

Скуп алата (\verb|toolchain|) је комплетна инсталација \verb|Rust| компајлера (\verb|rustc|) и сродних алата као што 
је \verb|Cargo|. Скуп алата се инсталира и ажурира уз помоћ програма командне линије \verb|rustup| \ref{lst:rustup_set}. 

\begin{listing}[H]
\begin{minted}{text}
    rustup toolchain install [version]
\end{minted}
\caption{Инсталирање новог скупа алата}
\label{lst:rustup_set}
\end{listing}

Програм \verb|rustup| аутоматски одређује који скуп алата ће се користити приликом покретања компајлера. 
Постоји више начина да се контролише који скуп алата се примењује за неко про\hyp{}извољно окружење.
Ако први аргумент \verb|rustc| компајлера или \verb|Cargo| менаџера пакета почиње са "+" (без наводника) 
онда назначава име скупа алата који је пожељан да се користи \ref{lst:toolchain_cli}. 

\begin{listing}[H]
\begin{minted}{text}
    cargo +beta run 
    rustc +beta main.rs
\end{minted}
\caption{Конфигурисање скупа алата кроз аргументе командне линије}
\label{lst:toolchain_cli}
\end{listing}

Уколико не постоји приказује се порука да скуп 
алата није инсталиран или да га је немогуће добавити. Променљива окружења \verb|RUSTUP_TOOLCHAIN| специфицира 
подразумевани скуп алата. Скуп алата је могуће применити на нивоу директоријума употребом \verb|rustup| \verb|override|
команде \ref{lst:toolchain_dir}. 

\begin{listing}[H]
\begin{minted}{text}
    rustup override set beta 
\end{minted}
\caption{Конфигурисање скупа алата над директоријумом}
\label{lst:toolchain_dir}
\end{listing}

Алтернативно креирањем конфигурационог фајла \verb|rust-toolchain.toml| у коренском 
дире\hyp{}кторијуму пројекта могуће је специфицирати скуп алата за тај пројекат \ref{lst:toolchain_cfg}.

\begin{listing}[H]
\begin{minted}{toml}
[toolchain]
channel = "nightly-2020-07-10"
components = [ "rustfmt", "rustc-dev" ]
targets = [ "wasm32-unknown-unknown", "thumbv2-none-eabi" ]
profile = "minimal"
\end{minted}
\caption{Конфигурисање скупа алата уз помоћ конфигурационог фајла}
\label{lst:toolchain_cfg}
\end{listing}

Овај начин је најоптималнији у продукционим пројектима уколико се користи скуп алата који 
није подразумеван будући да је конфигурациони фајл далеко опсежнији и обухвата мете компа\hyp{}јлирања и 
потребне компоненте. Мете компајлирања су дистрибуције за које се компаљира \verb|Rust| програм.
Сваки скуп алата садржи компоненте од којих су неке опционе а неке неопходне. Једна од најкоришћенијих 
опционих компоненти јесте \verb|clippy| који служи да предупреди што више честих грешака уз помоћ 
700 нових упозорења. 


За приказ доступних локалних верзија, као и тренутна активна верзија у директоријуму користи се \verb|rustup|
\verb|show| команда \ref{lst:rustup_show}.

\begin{listing}[H]
\begin{minted}{text}
    >rustup show
    installed toolchains
    --------------------
    stable-x86_64-unknown-linux-gnu (default)
    nightly-x86_64-unknown-linux-gnu
    active toolchain
    ----------------
    nightly-x86_64-unknown-linux-gnu (directory 
    override for '/home/abajat/Documents/projects/master')
    rustc 1.83.0-nightly (12b26c13f 2024-09-07)
\end{minted}
\caption{Приказ излаза "rustup show" команде}
\label{lst:rustup_show}
\end{listing}

Кључна особина \verb|Rust| језика јесте стабилност без стагнације. Једном када се нова 
функци\hyp{}оналност језика објави у стабилној верзији, контрибутори ће одржавати 
ту функционалност у свим наредним верзијама \cite{editions}.
Ране верзије \verb|Rust|-а нису поседовале \verb|async| и \verb|await| кључне речи.
Када би \verb|Rust| без мера предострожности увео нове кључне речи, нека количина кода би била покварена.

\begin{listing}[H]
\begin{minted}{rust}
    // validan rust kod 
    // ali nije validan ako je edicija posle 2018 uključena
    let async = 5; 
\end{minted}
\caption{Некомпатибилност приликом промене едиције}
\label{lst:edition}
\end{listing}


\verb|Rust| користи едиције да би решио овај проблем. Ако постоје промене које су уназад 
неко\hyp{}мпатибилне онда постају састав следеће едиције. Едиција се мора експлицитно навести 
у \verb|Cargo.toml| конфигурационом фајлу да би се функционалности укључиле \ref{lst:edition_toml}. Креирање новог пројекта уз 
помоћ менаџера пакета \verb|Cargo| аутоматски бира последњу доступну верзију.
\verb|Crate|-ови различитих едиција су компатибилне између себе. Компатибилност омогућује 
карактеристика \verb|Rust| компајлера да приликом компајлирања преводи сваки \verb|Crate| на исту међу репрезентацију 
кода без обзира на едицију. Омогућавање оваквог нивоа компатибилности лимитира ниво промене 
који се може очекивати у едицији. Миграција на нову верзију \verb|Rust|-а је обично лака и претежно аутоматизована
и спроводи се кроз \verb|Cargo|. Аутоматске миграције нису савршене и могуће је да је потребан ниво мануелног 
труда да би се у потпуности завршио процес.

\begin{listing}[H]
\begin{minted}{toml}
[package]
name = "some_crate"
version = "0.1.0"
edition = "2021"

\end{minted}
\caption{Експлицитно навођење едиције у Cargo.toml фајлу}
\label{lst:edition_toml}
\end{listing}

Подразумевано понашање \verb|rustc| компајлера могуће је променити употребом променљивих окружења 
и заставица функционалности (\verb|feature| \verb|flags|). Комплетан списак омогућених заставица функционалности 
за коришћени скуп алата се може приказати употребом \verb|--help| опције \verb|rustc| компајлера \ref{lst:rustc_flags}.

\begin{listing}[H]
\begin{minted}{bash}
    rustc --help -v 
\end{minted}
\caption{Приказ свих омогућених заставица функционалности}
\label{lst:rustc_flags}
\end{listing}

Главни подскуп заставица функционалности се бави генерисањем кода. Наводе се коришћењем \verb|-C| префикса. 
Будући да генерисање кода извршава 
\verb|LLVM| сет алата, доступан је широк дијапазон опција. Нивои оптимизације кода, као и циљани процесор за који 
се код компајлира су нека од битнијих подешавања. Заставица \verb|emit| је изузетно битна јер омогућава избор 
додатних излазних артефакта који се траже од компајлера. Битнији артефакти су \verb|LLVM| биткод, \verb|LLVM| међу 
репрезентација и асемблерски код.

\begin{listing}[H]
\begin{minted}{bash}
    cargo rustc -- --emit=llvm-bc
    cargo rustc -- --emit=llvm-ir
    cargo rustc -- --emit=asm
\end{minted}
\caption{Генерисање додатних излазних артeфакта}
\label{lst:emit_flag}
\end{listing}


\verb|Rust| се одликује са два начина компилације, комплетна 
и инкрементална. Комплетна компилација је подразумевана и \verb|Crate| се компајлира од почетка сваки пут.
Инкрементална компилација се укључује уз помоћ заставица функционалности где се приликом компајлирања 
бележе излази који могу да се искористе у наредном процесу компајлирања \ref{lst:incremental_flag}. Инкрементална компилација је 
ефективна у случају да је \verb|Crate| веома велик и смањује време секвенцијалних компилација. Приликом овог 
вида компилације чува се значајно више података тј. додатне перформансе се добијају на уштрб меморије на диску.
Самим тиме ово није ефективан метод компајлирања у \verb|CI/CD| окружењима јер агент који врши компајлирање
обично није детерминистички. Кеширање излаза инкременталне компилације и коришћење истог у несеквнцијалној 
компилацији може бити спорије него комплетно компајлирање услед баченог процесорског времена на проверу 
излаза који се не могу поново искористити.

\begin{listing}[H]
\begin{minted}{text}
    cargo rustc -- -C incremental=true 
\end{minted}
\caption{Инкрементална компилација Crate-a}
\label{lst:incremental_flag}
\end{listing}


Ноћна верзија \verb|Rust| компајлера се одликује проширеним скупом заставица функционалности које се зову 
нестаблине заставице функционалности. Наводе се коришћењем \verb|-Z| префикса. У овом скупу се налазе 
заставице које су изузетно корисне приликом развоја \verb|rustc|-а али и заставице које се развијају
и које ће потенцијално бити део нове верзије \verb|rustc|-а. Једна од најбитнијих заставица у развоју 
јесте \verb|unpretty| која може да прикаже изворни код у некој међу репрезентацији као што су
апстрактно синтаксно стабло, висока међу репрезентација и средња међу репрезетација \ref{lst:intermediate_representation}.

\begin{listing}[H]
\begin{minted}{bash}
    # Apstraktno sintaksno stablo 
    cargo +nightly rustc -- -Z unpretty=ast-tree
    # Visoka medju reprezentacija
    cargo +nightly rustc -- -Z unpretty=hir
    # Srednja medju reprezentacija
    cargo +nightly rustc -- -Z unpretty=mir
\end{minted}
\caption{Приказ међурепрезентација изворног кода}
\label{lst:intermediate_representation}
\end{listing}
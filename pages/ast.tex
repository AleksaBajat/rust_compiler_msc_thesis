\subsection{Апстрактно синтаксно стабло}

Парсер језика \verb|Rust| уз помоћ тока токена из лексера генерише апстрактно синтаксно стабло (АСТ). 
Приликом позива парсирања, једини фајл који се одмах процесира јесте главни \verb|main| фајл, потпуно стабло
настаје путем експанзије и резолуције имена.
Алгоритам \verb|recursive-descent| се користи током процеса парсирања. Ово је једна од најједноставнијих
техника парсирања која се користи у пракси. Овакви парсери се такође називају \verb|top-down| парсери 
јер конструишу стабло од горе ка доле \cite{parsing}. 

Парсер користи претходно поменути ток токена да би креирао курсор над стаблом токена \verb|TokenTreeCursor|.
\verb|TokenStream| поседује имплементацију \verb|into_tree| који трансформише тип добијен из лексера
у тип погодан парсеру.

\begin{listing}[H]
\begin{minted}{rust}
pub fn into_trees(self) -> TokenTreeCursor {
    TokenTreeCursor::new(self)
}

impl TokenTreeCursor {
    fn new(stream: TokenStream) -> Self {
        TokenTreeCursor { stream, index: 0 }
    }
    ...
}
\end{minted}
\caption{Конверзија из "TokenStream" у "TokenTreeCursor"}
\end{listing}

Једноставније је итерирати кроз стабла токена секвенцијално у односу на структуру која личи на канапе.

За разлику од лексера, парсер поседује конструкте који су доста сложенији од једног токена, као што су 
структуре, енумерације и слично (реч-реченица поређење). Изворни чвор \verb|AST|-а је \verb|Crate|.

\begin{listing}[H]
\begin{minted}{rust}
#[derive(Clone, Encodable, Decodable, Debug)]
pub struct Crate {
    pub attrs: AttrVec,
    pub items: ThinVec<P<Item>>,
    pub spans: ModSpans,
    pub id: NodeId,
    pub is_placeholder: bool,
}
\end{minted}
\caption{Дефиниција "Crate" структуре}
\end{listing}

Најбитнија поља су атрибути (\verb|attrs|) и ставке (\verb|items|). Атрибути могу бити спољашњи или унутрашњи.
Користе се да би корисник пружио додатне инструкције компајлеру. 
Додатне инструкције могу бити тривијалне попут дозвољавања
некоришћеног кода, али могу бити и комплексније у виду имплементације особина 
(\verb|trait|). Особина је функционалност веома слична интерфејсу у другим језицима. 

Ставке су групације токена из лексера које тако груписане имају семантику. Из перспективе кода 
веома се мало разликује од самог \verb|Crate|-а. Свака ставка поседује идентификатор \verb|NodeId| 
који представља секвенцијални број ставке унутар \verb|Crate|-а. Ово значи да уколико се усред стабла 
обрише или изгенерише нова ставка, сваки чвор након тог дела стабла мора поново да изгенерише свој редни број.
Самим тиме апстрактно синтаксно стабло није корисно приликом инкременталне компилације јер су идентификатори
волотилни. Свака ставка такође садржи \verb|Span|. Ово је тип који одређује почетну и крајњу позицију 
ставке унутар изворног кода. У односу на вредност типа \verb|kind|, ставке могу или не могу да поседују атрибуте. 

\begin{listing}[H]
\begin{minted}{rust}
#[derive(Clone, Encodable, Decodable, Debug)]
pub struct Item<K = ItemKind> {
    pub attrs: AttrVec,
    pub id: NodeId,
    pub span: Span,
    pub vis: Visibility,
    pub ident: Ident,
    pub kind: K,
    pub tokens: Option<LazyAttrTokenStream>,
}
\end{minted}
\caption{Дефинциија "Item" структуре}
\end{listing}

\begin{listing}[H]
\begin{minted}{rust}
pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {
    let (attrs, items, spans) = self.parse_mod(&token::Eof)?;
    Ok(ast::Crate { attrs, items, spans, 
       id: DUMMY_NODE_ID, is_placeholder: false })
}
\end{minted}
\caption{Улазна функција парсера}
\end{listing}


Резолуција имена је један од делова формирања апстрактног синтаксног стабла.
У програмима се референцирају функције, варијабле и типови на основу имена. Ова имена нису увек јединствена.

\begin{listing}[H]
\begin{minted}{rust}
type a = u32;
let a: a = 1;
let b: a = 5; 
\end{minted}
\caption{Резолуција имена}
\label{lst:resolution}
\end{listing}

Како знамо, у изворном коду \ref{lst:resolution}, да ли је у линији 3 "а" тип или вредност 1?
Овакви конфликти се решавају приликом резолуције имена. У датом случају имена типова и променљивих се налазе 
у различитим именским просторима (\verb|namespaces|) и због тога могу да коегзистирају.
Резолуција имена се изводи из два фазе. Прва фаза се дешава за време експанзије (више о томе у даљем тексту) 
где се обрађују само \verb|import|-и. Друга фаза се дешава након експанзије где се обрађује целокупно 
синтаксно стабло почевши од врха па на доле. 

Имена су валидна у различитим деловима изворног кода. Да би се 
време живота (\verb|scope|) неког имена проверило уводи се концепт ребара (\verb|rib|). Сваки пут када се 
сет видљивих имена потенцијално мења ново ребро се гура на стек. Примери ситуација у којима се додаје 
ново ребро:

\begin{enumerate}
    \item Очигледна места као што су витичасте заграде, функције, модули.
    \item Приликом позива \verb|let| јер се име може редефинисати (\verb|shadowing|).
    \item Почетак проширења макроа. 
\end{enumerate}
Потрага за именом се изводи од најдубљег ребра (врх стека) ка најплићем. 
Редослед је веома битан зато што се оваквом претрагом избегава грешка 
уколико је неко име редефинисано.

\begin{listing}[H]
\begin{minted}{rust}
let a: u32 = 1;
let a: i32 = -1;
\end{minted}
\caption{"Shadowing"}
\label{lst:shadowing}
\end{listing}

Језици као што је \verb|C| поред компајлера садрже препроцесор који прикупља изворни код. 
Приликом прикупљања изворног кода скраћенице (макрои) се проширују на изразе програмског језика. 
\verb|Rust| се одликује веома моћним макроима али не поседује препроцесор. Трансформација скраћеница се врши 
путем експанзије.  Експанзија је процес током ког се допуњује апстрактно синтаксно стабло
проширивнајем макроа и уметањем модула (\verb|inlining|). Приликом парсирања уместо 
модула и макроа се постављају АСТ фрагменти. Ови фрагменти су почетне тачке алгоритма експанзије.
Креира се ред чекања непроширених макроа. Један по један се узимају из реда чекања, вриши се резолуција имена,
проширују се и интегришу назад у стабло. У случају да се нема напретка (лоше написан код), враћа се грешка.

Пре него што почне прелазак у следећи посредни облик АСТ стабло се валидира. 
Током проласка се проверава да ли је стабло синтактички валидно, без икаквих комплексних анализа,
резолуције имена или провера типова. Ово није могуће учинити приликом парсирања јер макро атрибути 
омогућавају одређене делове нетачне синтаксе као што је функција без тела ван дефиниције особине (\verb|trait|) \ref{lst:validate}.

\begin{listing}[H]
\begin{minted}{rust}
#[proc_macro_attribute]
pub fn expand_body(_attr: TokenStream, _item: TokenStream) -> TokenStream {
    let fun = format!("fn missing_body() 
    {{ println!(\"I'm not missing body anymore.\"); }}");
    let stream: TokenStream = fun.parse().unwrap();
    stream
}
#[expand_body]
fn missing_body();
fn main() {
    missing_body();
}
\end{minted}
\caption{Додавање тела функције уз помоћ макроа}
\label{lst:validate}
\end{listing}

Апстрактно синтаксно стабло пре и после експанзије неког \verb|Crate|-а се може анализирати помоћу 
нестабилних \verb|-Z| заставица \ref{lst:rustc_ast}.

\begin{listing}[H]
\begin{minted}{bash}
cargo rustc -- -Z unpretty=ast
cargo rustc -- -Z unpretty=ast,expanded
\end{minted}
\caption{Приказ апстрактног синтаксног стабла}
\label{lst:rustc_ast}
\end{listing}